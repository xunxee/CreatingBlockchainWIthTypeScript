# 목차

- [변수란 무엇인가? 왜 필요한가?](#1-변수란-무엇인가-왜-필요한가)
- [식별자](#2-식별자)
- [변수 선언](#3-변수-선언variable-declaration)
- [변수 선언의 실행 시점과 변수 호이스팅](#4-변수-선언의-실행-시점과-변수-호이스팅)
- [값의 할당](#5-값의-할당)
- [값의 재할당](#6-값의-재할당)

## **1. 변수란 무엇인가? 왜 필요한가?**

```
10 + 20
```

사람이 위 식을 계산하려면 `10`, `20`, `+` 라는 기호의 의미를 알고 있어야한다. 컴퓨터, 즉 자바스크립트를 해석하고 실행하는 자바스크립트 엔진도 사람과 유사하게 위 자바스크립트 코드를 실행한다. `10`, `20`, `+` 라는 기호(리터럴 literal과 연산자 operator)의 **의미를 알고 있어야** 하며, `10 + 20` 이라는 식(표현식 expression)의 의미도 해석(parsing)할 수 있어야 한다.

자바스크립트 엔진이 `10 + 20` 이라는 식의 의미를 해석하면 `+` 연산을 수행하기 위해 먼저 `+` 연산자의 좌변과우변의 숫자 값, **즉 피연산자(operand)를 기억**한다. 사람은 계산과 기억을 모두 두뇌에서 하지만,컴퓨터는 연산과 기억을 수행하는 부품이 나눠져 있다. **컴퓨터는 CPU를 사용해 연산**하고, **메모리를 사용해 데이터를 기억**한다.

> 메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체이다. **메모리 셀** 하나의 크기는 **1바이트(8비트)**이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 읽어 들인다. 각 셀은 고유의 메모리 주소를 갖는다. 이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현된다.
> 

> 컴퓨터는 모든 데이터를 **2진수**로 처리한다. 따라서 메모리에 저장되는 데이터는데이터의 종류(숫자, 텍스트, 이미지, 동영상 등)와 상관없이 모두 2진수로 저장된다. 그림에는 메모리에 저장된 숫자 값을 편의상 10진수로 표기했다. 하지만 메모리에 저장되는 **모든 값은 2진수로 저장된다**는 것을 기억해야한다.
> 

![https://user-images.githubusercontent.com/87808288/165231816-3a6d5b0d-c54e-46c3-ac47-22cab66afe9c.png](https://user-images.githubusercontent.com/87808288/165231816-3a6d5b0d-c54e-46c3-ac47-22cab66afe9c.png)

연산 결과가 메모리에 저장되었지만 문제가 있다. CPU가 연산에서 만들어낸 숫자 값 `30`을 재사용할 수 없다는 것이다. 메모리 주소를 통해 연산 결과 `30`이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다. **메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를** 발생시킬 가능성이 높은, 매우 위험한 일이다.(실수로 운영체제가 사용하고 있는 값을 변경하면 시스템을 멈추게 할 수 있는 치명적인 오류가 발생할 수 있다.)

프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, **저장된 값을 읽어 들여 재사용**하기 위해 **변수**라는 메커니즘을 제공한다. 변수는 **하나의 값을 저장하기 위해 확보한 메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙여진 이름**이다.

```jsx
let result = 10 + 20;
```

메모리 공간에 저장된 값을 다시 읽어 들여 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인 것이 바로 변수이다.

![https://user-images.githubusercontent.com/87808288/165236386-19f702ac-18ae-4da2-807f-c79cf078a199.png](https://user-images.githubusercontent.com/87808288/165236386-19f702ac-18ae-4da2-807f-c79cf078a199.png)

**변수에 값을 저장**하는 것을 **할당(assignment)**이라 하고, **변수에 저장된 값을 읽어 들이는 것**을 **참조(reference)**라 한다.

## **2. 식별자**

변수 이름을 **식별자(identifier)**라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 **고유한 이름**을 말한다.

값은 메모리 공간에 저장되어 있다. 따라서 식별자는 **메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야** 한다. 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 한다. 이처럼 **식별자는 값이 아니라 메모리 주소를 기억**하고 있다.

식별자라는 용어는 변수 이름에만 국한해서 사용하지 않는다. 예를 들어 변수, 함수, 클래스 등의 이름은 모두 식별자다. 즉 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

## **3. 변수 선언(Variable Declaration)**

변수 선언이란 변수를 생성하는 것을 말한다. 좀 더 자세히 말하면 **값을 저장하기 위한 메모리 공간을 확보**하고 **변수 이름과 확보된 메모리 공간의 주소를 연결**해서 값을 저장할 수 있게 준비하는 것이다.

변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용한다.

```jsx
var score; //변수 선언
```

![https://user-images.githubusercontent.com/87808288/165242090-4306d2ea-5f0f-484f-b865-6db3df761b33.png](https://user-images.githubusercontent.com/87808288/165242090-4306d2ea-5f0f-484f-b865-6db3df761b33.png)

**변수를 선언**한 이후, 아직 변수에 값을 할당하지 않았다. 따라서 변수 선언에 의해 확보된 메모리 공간은 비어 있을 것이라고 생각할 수 있으나 확보된 메모리 공간에는 **JS 엔진에 의해 undefined라는 값이 암묵적으로 할당**되어 초기화된다. 이것은 JS의 독특한 특징이다. `var` 키워드를 사용한 **변수 선언**은 **선언 단계와 초기화 단계가 동시에 진행**된다.

## **4. 변수 선언의 실행 시점과 변수 호이스팅**

변수 선언문보다 변수를 참조하는 코드가 앞에 있다.

```jsx
console.log(score);  // undefined

var score; // 변수 선언문
```

`console.log`가 실행되는 시점에는 아직 `score` 변수의 선언이 실행되지 않았으므로 참초 에러가 발생할 것 처럼 보인다. 하지만 에러가 발생하지 않고 `undefined`가 출력된다. 그 이유는 **변수 선언**이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 **런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문**이다.

> JS 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 이때 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 JS 엔진은 **변수 선언을 포함한 모든 선언문**(변수 선언문, 함수 선언문)을 **소스코드에서 찾아내 먼저 실행**한다.
> 

JS 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 이처럼 **변수 선언문**이 **코드의 선두로 끌어 올려진 것처럼 동작**하는 JS 고유의 특징을 변수 **호이스팅**이라 한다.

## **5. 값의 할당**

변수에 값을 할당할 때는 할당 연산자(`=`)를 사용하게 된다.

```jsx
var score; //변수 선언
score = 80; //값의 할당

var score = 80; //변수 선언 + 값의 할당
```

변수 선언과 값의 할당을 다음과 같이 **하나의 문(statement)으로 단축 표현**할 수 있다.

> JS 엔진은 변수 선언과 값의 할당을 하나의 문으로 **단축 표현해도 변수 선언과 값의 할당**을2개의 문으로 나누어 **각각 실행**한다. 이때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것이다. **변수 선언**은 소스코드가 순차적으로 실행되는 시점인 **런타임 이전에 먼저 실행**되지만 **값의 할당**은 소스코드가 순차적으로 실행되는 시점인 **런타임에 실행**된다.
> 

```jsx
console.log(score); // undefined 

var score;
score = 80;

console.log(score); // 80
```

변수에 값을 할당할 때는 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 `80`을 새롭게 저장하는 것이 아니라 **새로운 메모리 공간을 확보**하고 그곳에 할당 값 `80`을 저장한다.

![https://user-images.githubusercontent.com/87808288/165282896-a5a80b1c-a096-4024-8105-40570a504dac.png](https://user-images.githubusercontent.com/87808288/165282896-a5a80b1c-a096-4024-8105-40570a504dac.png)

## **6. 값의 재할당**

`var` 키워드로 선언한 변수는 값을 재할당 할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. `var` 키워드로 선언한 변수는 선언과 동시에 `undefined`로 초기화되기 때문에 엄밀히 말하자면**변수에 처음으로 값을 할당하는 것도 사실은 재할당**이다.

> 처음 값을 할당했을 때와 마찬가지로 이전 값 `80`이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에재할당 값 `90`을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 `90`을 저장한다.
> 

![https://user-images.githubusercontent.com/87808288/176883479-2178c611-afe7-458a-a6ca-46e03c4ca912.png](https://user-images.githubusercontent.com/87808288/176883479-2178c611-afe7-458a-a6ca-46e03c4ca912.png)

현재 `score` 변수의 값은 `90`이다. `undefined`와 `80`은 더이상 필요하지 않다는 것을 의미한다. 이러한 불필요한 값들은 **가비지 콜렉터에 의해 메모리에서 자동 해제**된다.