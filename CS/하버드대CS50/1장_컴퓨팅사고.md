# 목차

- [2진법](#1-2진법)
- [정보의 표현](#2-정보의-표현)
- [알고리즘](#3-알고리즘)

# **1. 2진법**

## **(1) 컴퓨터 과학**

컴퓨터 과학은 **문제 해결에 대한 학문**이다. 컴퓨터 과학의 시작은 기계들을 사용할 때 **입력과 출력**을 어떻게 표현할 것인지에서 시작한다. 바로 **정보 자체의 표현 방법**을 나타내는 것이다.

우리는 10진법을 사용하지만 컴퓨터는 **2진법**이라는 개념을 사용한다.

🔥 **123**

우리가 `123`을 ‘백이십삼’으로 읽을 수 있는 이유는 1을 백의 자리로, 2를 십의 자리로, 3을 일의 자리로 인식하기 때문이다. 

```jsx
1 * 100 + 2 * 10 + 3 * 1
```

우리는 위의 과정을 아주 당연하게 받아드리는데, 우리가 **각 자리수**를 `10`**의 거듭제곱으로 표현**했기 때문이다. 비슷하게도 **2진법**에서도 **각 자리수가** `2`**의 거듭제곱**을 의미한다.

<img src="https://user-images.githubusercontent.com/87808288/163469769-46979126-b6e6-46f3-903f-c9fb80a0ad40.png" width="60%">

10진법의 `3`을 2진법으로 표현하면 어떻게 해야할까? 정답은 `11`이다.

```jsx
2 * 1 + 1 * 1
```

## **(2) bit**

2진법은 전기를 통해 연산하는 전기를 끄고 켜는 것으로 작동하는 컴퓨터에게 적합한 방법이다. 이렇게 컴퓨터는 2진법에서 하나의 자릿수를 표현하는 단위를 **비트**(**bit**)라고 한다. 비트는 이진 숫자라는 뜻을 가진 “binary digit”의 줄임말로 0과 1, 이렇게 두 가지 값만 가질 수 있는 측정의 단위이다. 하지만 이런 비트로는 많은 양의 데이터를 나타내기는 턱없이 부족할 수 밖에 없다.

<img src="https://user-images.githubusercontent.com/87808288/163472189-709b4e4e-adde-40c3-afde-13e9446ae701.png" width="40%">

## **(3) byte**

많은 양의 데이터를 표현하기 위해 **비트열**을 이용하게 되었는데 **바이트**(**byte**)는 **여덟 개의 비트가 모여** 만들어진 것이다. 하나의 바이트에는 여덟 개의 비트가 있고 비트 한 개는 0과 1로 표현될 수 있기 때문에 `2 * 8 = 256`으로 256개의 서로 다른 바이트가 존재할 수 있게 된다.

<img src="https://user-images.githubusercontent.com/87808288/163472419-c53bf1a0-de4b-4f5c-a8a8-b833b88028d1.png" width="40%">

🔥 **생각해보기**

`5`를 2진법으로 바꿔보면, 10진법으로 `5`를 2진법으로 바꾸려면 일단 2진법은 각 자리수가 `2`**의 거듭제곱**을 의미한다. 따라서 `8, 4, 2, 1` 이렇게 거듭제곱이 진행되므로`0101`로 10진법의 `5`를 2진법으로 표현할 수 있다.

# **2. 정보의 표현**

## **(1) 문자의 표현**

**문자를 숫자로 표현**할 수 있는 정해진 약속(표준)이 존재한다. 그중 하나가 바로 **ASCII**이다.

<img src="https://user-images.githubusercontent.com/87808288/163576701-b41f5f7b-5825-44d1-9772-3688fe208fbf.png" width="60%">

대문자 ‘A’는 10진법으로 `65`로 표현하는데, 이를 2진법으로 바꾸면 

```jsx
2^6 * 1 + 2^5 * 0 + 2^4 * 0 + 2^3 * 0 + 2^2 * 0 + 2 * 0 + 1 * 1(64 + 1)
```

로 나타낸다. 이렇게 컴퓨터는 ‘A’를 숫자 `65`로 정했다.(`01000001`) 이외에도 **Unicode**를 통해, 더 많은 비트를 사용하여 더 다양한 문자들도 표현할 수 있도록 지원하고 있다. **ASCII로는 표현할 수 있는 수에 한계**를 가지기 때문이다.

## **(2) 그림, 영상, 음악의 표현**

문자를 비롯해 그림 또한 숫자로 표현할 수 있다. 우리가 스크린을 통해 접하는 그림을 자세히 살펴 보면 수많은 점들이 **빨간색**, **초록색**, **파란색**을 띄고 있다. 이렇게 작은 점을 우리는 **픽셀**이라 부른다.

각각의 픽셀은 세 가지 색을 서로 다른 비율로 조합하여 특정한 색을 나타내게 된다. 예를 들어 빨간색 72, 초록색 72, 파란색 33을 섞으면 노란색이 되는 것과 같은 방식이다. 이 숫자들을 표현하는 방식을, 우리는 **RGB**라고 부른다. 어떤 방법을 사용해서 정보를 나타내든 **결국 0과 1로 표현**된다.

# **3. 알고리즘**

컴퓨팅은 **입력**을 받아 입력을 **출력**하는 하나의 과정이라 할 수 있다. **알고리즘**은 **입력에서 받은 자료를 출력 형태로 만드는 처리 과정**이라 할 수 있다.

<img src="https://user-images.githubusercontent.com/87808288/163664173-9eb2c256-794b-40a6-9bbb-e8fb8f68fb09.png" width="40%">

알고리즘은 **입력값을 출력값의 형태로 바꾸기 위해** 어떤 명령들이 수행되어야 하는지에 대한 **규칙들의 순서적 나열**이다. 이렇게 순서적 규칙들을 어떻게 나열하느냐에 따라 알고리즘의 종류가 달라지게 되는 것이다. 또한 같은 출력값을 도출한다하여도 알고리즘의 종류에 따라 그 출력을 하기까지의 시간이 다를 수 있다.

## **(1) 정확한 알고리즘**

> 전화번호부에서 '정건희'라는 이름을 찾는 다고 가정한다면 전화번호부의 첫 페이지를 펼친 후 ‘정건희’라는 이름이 해당 페이지에 있는지 찾는 과정을 실행한다. 없으면 그 다음 페이지로 넘어가서 위의 과정을 반복한다.
> 

이 과정을 반복하다보면, ‘정건희’라는 이름이 전화번호부에 존재한다면 위의 과정을 반복하여 ‘정건희’를 찾을 수 있을 것이다.

알고리즘을 평가할 때는 **정확성**도 중요하지만, **효율성도 중요**하다.

- 효율성 → 작업을 완료하기까지 얼마나 시간과 노력을 덜 들일 수 있는지에 대한 것

위의 알고리즘은 한 번에 한 페이지씩 확인하므로 알고리즘은 정확하지만, 매우 오래걸리고 비효율적이다. 이럴 때는 두 페이지를 넘기게하여 알고리즘의 효율성을 개선할 수도 있다. 하지만 ‘정건희’라는 페이지가 그냥 넘어갈 수 있으니 정확도면에서는 문제가 발생할 수 있다.

## **(2) 정확하고 효율적인 알고리즘**

보다 효율적이면서도 정확한 알고리즘을 적용하려한다.

> 전화번호부의 가운데를 펼치고 만약 ‘정건희’가 있다면 알고리즘을 끝낸다. 없다면 전화번호부가 이름순으로 정렬되어 있으므로 ‘정건희’라는 이름이 지금 페이지보다 앞에 있는지 뒤에 있는지 알 수 있을 것이다. 따라서 전화번호부의 절반을 버릴 수 있게 되고 남은 절반에 대해 위와 같은 알고리즘을 수행할 수 있다. 위의 과정을 ‘정건희’가 발견될 때까지 반복하게된다. 남은 한 페이지는 ‘정건희’가 있거나 없거나 두 개의 결과만을 도출하게된다.
> 

위의 알고리즘은 **이전의 알고리즘보다 효율적**이다.

기존의 전화번호부가 100페이지이고, 100페이지가 추가되어 200페이지라면? 한장씩 넘기는 첫번째 알고리즘은 100번의 페이지를 모두 넘겨야하지만, 절반씩 줄어드는 두 번째 알고리즘은 단 1번의 절차만 더 수행하면 된다. (200페이지로 늘어났다고하여도 200페이지의 절반을 날리면 바로 100페이지가 남는다!) 단 한 번의 동작으로 200페이지의 절반인 100페이지가 사라지기 때문이다.

## **(3) 의사코드**

위와 같은 알고리즘은 아래와 같은 **의사코드**라는 방식으로 보다 명료하게 작성할 수 있다. 의사코드는 컴퓨터가 수행할 작업을 프로그램 언어가 아니라 **사람이 사용하는 언어로 알고리즘의 논리적 절차를 작성한 코드**를 말한다.

```jsx
1 Pick up phone book
2 Open to middle of phone book
3 Look at page
4 If 정건희 is on page
5   Call 정건희
6 Else if 정건희 is earlier in book  
7   Open to middle of left half of book
8   Go back to line 3  
9 Else if 정건희 is later in book  
10  Open to middle of right half of book  
11  Go back to line 3  
12 Else  
13  Quit
```

> *나의 블로그: [1장 컴퓨팅 사고](https://www.notion.so/1-46d1a3ebd845483bb743e05d69dde246)*
>